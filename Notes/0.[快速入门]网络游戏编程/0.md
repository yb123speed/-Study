# 0.[快速入门]网络游戏编程

## 网络游戏的层次体系

层级 | 作用
------------- | -----------
第7层表示层 | 游戏中的所有通讯协议
第6层表示层 | (通过RPC协议传输)序列化游戏数据的方式
第5层会话层 | 通讯中断后重新连接
第4层传输层 | TCP(UDP)
第3层网络层 | IP
第2层数据链路层 | 无线局域网、千兆以太网
第1层物理层 | 物理线路和双绞线电缆

## 0.1 网络游戏开发者所需了解的网络编程基础

第4层大多使用TCP协议、不需要直接操纵第3层以下的分层。如果要求收发信号按顺序、可靠地进行传输，就是使用TCP协议；如果对此不作要求，就可以使用UDP。网络游戏只有在必要的情况下才使用UDP，除此之外一概用TCP。

### 套接字API的基础知识：

推荐书籍：《UNIX网络编程》系列图书

使用套接字API可以控制第3层的IP协议、第4层的UDP、TCP、ICMP等协议。网络游戏只使用“**第4层的套接字API**”。

  协议 | * | 应用
----------|---------------------|---------------
TCP | 面向连接(流式，STREAM) | HTTP、SSH
UDP | 无连接(数据报式，DGRAM) | DNS

------------------------------------------------------------------------

## 0.2 套接字编程入门

IP是由位于通信链路端点的一个IP地址(32位)和一个端口号(16位)来指定的。16位的端口可以由服务器的实现者酌情决定(排除一些固定端口，可以在IANA的端口表查询)。

### 套接字API基础(Echo服务器和客户端示例)

Server:

```c
int sock = socket(PF_INET, SOCK_STREAM);  //指定类型生成等待使用的套接字（文件描述符）
bind(sock, addr); //设置监听端口号
listen(sock); //监听开始。待机中
while(1) {
    int new_sock = accept(sock, &addr); //在新连接到来之前一直“等待”（阻塞）,当连接请求来到后，返回新的套接字，建立连接

    char buf[100];
    size_t size = read(new_sock, buf, 100);//在读满最大的100字节之前一直等待（在数据到达前或是连接中断时阻塞）

    if(size == 0){
        close(new_sock); //如果read函数返回了0，意味着接收到了EOF，关闭连接
    } else {
        write(new_sock, buf, size); //没有收到EOF的话就写入size个字节的数据
    }
}

```

Client:

```c
int sock = socket(PF_INET, SOCK_STREAM);  //生成新的套接字（文件描述符）
connect(sock, addr); //使用生成的套接字，向指定的地址和端口进行连接，在连接终止前等待

while(1){
    write(sock,"ping");//写入数据
    char buf[100];
    read(sock, buf, 100); //等待读取数据。期待数据返回，永远往返通信。
}
```

### TCP通信链路的状态迁移和套接字API

待补充

### 处理多个并发连接

同时控制多个套接字的方法：

1. ~~每次连接时启动一个进程~~ (**不适用于网络游戏**)
2. 实行异步的多重输入输出（多重I/O）
3. 使用线程并行进行同步处理

### 同步调用（阻塞）和线程

connect()、accept()、read()这类“**永远等待着**”的函数成为阻“**阻塞**”（Blocking）

处理阻塞一般使用线程（Thread），注意最佳线程数是操作系统同时执行进程或线程数的4到10倍以内，不然OS内部切换的开销会变得很大。

Echo Server （线程版，阻塞）:

```c
int sock = socket(PF_INET, SOCK_STREAM);
bind(sock, addr);
listen(sock);
while(1) {
    int new_sock = accept(sock, &addr);
    create_thread({
        char buf[100];
        size_t size = read(new_sock, buf, 100);
        if(size == 0){
            close(new_sock);
        } else {
            write(new_sock, buf, size);
        }
    })
}
```